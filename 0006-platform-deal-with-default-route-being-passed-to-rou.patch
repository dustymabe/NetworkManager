From ace746df4e2936ab50224d9fbef88025b69d2379 Mon Sep 17 00:00:00 2001
From: Dan Winship <danw@gnome.org>
Date: Fri, 24 Oct 2014 13:48:46 -0400
Subject: [PATCH] platform: deal with default route being passed to
 route_sync() (bgo 735325)

NMIP4Configs and NMIP6Configs are never supposed to contain a default
route, and thus nm_platform_ip6_route_sync() should never have to deal
with one. Unfortunately, if it *does* get passed a default route, it
will add it even if it was already there. This will result in an
RTM_NEWROUTE notification, which will cause NMPlatform to emit
ip6-route-changed, which will result in NMDevice doing some work and
then calling nm_ip6_config_commit(), which will result in NMIP6Config
passing the same list of routes to nm_platform_ip6_route_sync() again,
including the default route, which will cause NMPlatform to add the
route again...

(Something eventually causes this cycle to get broken, but it starts
up again the next time NM receives an RA.)

Fix this by having the route_sync() functions never add/modify the
default route (They were already not deleting it.)
---
 src/platform/nm-platform.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/src/platform/nm-platform.c b/src/platform/nm-platform.c
index 75e6448..5d478e8 100644
--- a/src/platform/nm-platform.c
+++ b/src/platform/nm-platform.c
@@ -1908,6 +1908,9 @@ array_contains_ip6_route (const GArray *routes, const NMPlatformIP6Route *route)
  * with the least possible disturbance. It simply removes routes that are
  * not listed and adds routes that are.
  *
+ * @known_routes should not contain a default route; if it does, it will be
+ * ignored.
+ *
  * Returns: %TRUE on success.
  */
 gboolean
@@ -1938,6 +1941,9 @@ nm_platform_ip4_route_sync (int ifindex, const GArray *known_routes)
 		for (i = 0; i < known_routes->len && success; i++) {
 			known_route = &g_array_index (known_routes, NMPlatformIP4Route, i);
 
+			if (known_route->plen == 0)
+				continue;
+
 			if ((known_route->gateway == 0) ^ (i_type != 0)) {
 				/* Make two runs over the list of routes. On the first, only add
 				 * device routes, on the second the others (gateway routes). */
@@ -1975,6 +1981,9 @@ nm_platform_ip4_route_sync (int ifindex, const GArray *known_routes)
  * with the least possible disturbance. It simply removes routes that are
  * not listed and adds routes that are.
  *
+ * @known_routes should not contain a default route; if it does, it will be
+ * ignored.
+ *
  * Returns: %TRUE on success.
  */
 gboolean
@@ -2006,6 +2015,9 @@ nm_platform_ip6_route_sync (int ifindex, const GArray *known_routes)
 		for (i = 0; i < known_routes->len && success; i++) {
 			known_route = &g_array_index (known_routes, NMPlatformIP6Route, i);
 
+			if (known_route->plen == 0)
+				continue;
+
 			if (IN6_IS_ADDR_UNSPECIFIED (&known_route->gateway) ^ (i_type != 0)) {
 				/* Make two runs over the list of routes. On the first, only add
 				 * device routes, on the second the others (gateway routes). */
-- 
1.9.3

